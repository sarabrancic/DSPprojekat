1     						/** @file projekat_module_main.c
2     						 *
3     						 *  This file defines the actual implementation of the functions for 
4     						 *  projekat_module.
5     						 */
6     						
7     						.include "dsplib/os_asm.h" # include the definition of ROM functions and OS global variables
7      >> open include file: C:/CirrusDSP/include/dsplib/os_asm.h
1+    						 /**
2+    						 * @file
3+    						 * @brief DSP OS support.
4+    						 *
5+    						 * Project/Subproject: Cirrus Logic C library/ccc <p>
6+    						 * Component: DSP OS support.
7+    						 *
8+    						 * Language: English, Code page: ASCII, Coding standard: MG-CPP-DOXY-OCT08 <p>
9+    						 */
10+   						/** @defgroup os_interface OS interface
11+   						 *  These functions are called at various points during system
12+   						 *  initialization, before normal audio processing begins.
13+   						 */
14+   						
15+   						/** @defgroup module_api Module API
16+   						 *  These data structures are required for the OS to be able to call
17+   						 *  audio processing code. Code is packaged as a <em>module</em>. 
18+   						 *  One or more modules can be linked together as an <em>overlay</em>.
19+   						 *
20+   						 *  Each module must declare an instance of a mct, mcv, and mif.
21+   						 *
22+   						 *  @ingroup os_interface
23+   						 */
24+   						 
25+   						/** @defgroup call_convention Calling conventions
26+   						 *  These typedefs specify calling conventions expected by the OS when calling
27+   						 *  certain application code entry points.
28+   						 *  @ingroup os_interface
29+   						 */
30+   						 
31+   						/** @defgroup useful_types Useful typedefs
32+   						 *  These typedefs are useful in dealing with data provided by the OS.
33+   						 *  @ingroup os_interface
34+   						 */
35+   						
36+   						 
37+   						 .if !defined(_framework_interface_asm_h_)
38+   	 0000				_framework_interface_asm_h_
39+   						
40+   						
41+   						
42+   						/* Module Control Vector peek/poke function prototypes.*/
43+   						
44+   						/**
45+   						 * @brief return the pointer to a module's Module Control Vector (MCV), if it exists.
46+   						 *
47+   						 * The relationship between memory maps, overlays, the "*.uld" file, modules, module interface table, module control
48+   						 * vector is as follows:
49+   						 *
50+   						 * \li A memory map partitions the DSP's memory into functional units such as Decoder (DEC),
51+   						 * Matrix Processing Modules (MPM), Virtual Processing Modules (VPM), and Post Processing Modules (PPM)
52+   						 * \li the binary file that is downloaded to an overlay, such as the PPM, has a .uld extension. Example: myPPM.ULD is downloaded to the PPM overlay.
53+   						 * \li The .uld has an overlay definition table (ODT) to determine what module or modules are present, and the order
54+   						 *  that this chain of modules processes audio data. The ODT is essentially an array, and each element points to a
55+   						 *  Module's Module Interface Table or MIF. If the PPM overlay has parametric EQ (PEQ), bass manager (BM), and audio manager (AM), and in that
56+   						 *  order, the ODT will have four entries- a pointer to the PEQ MIF, pointer to the BM MIF, pointer to the AM MIF,
57+   						 *  and then a terminating entry of zero.
58+   						 * \li Each module has a Module Interface table or MIF, which is an array of pointers. The first element in the MIF, or MIF[0], is a pointer to the
59+   						 * Module Control Vector or MCV. The second, or MIF[1], is a pointer to the Module Control Table or MCT.
60+   						 * \li cl_get_mcv_pointer returns MIF[0] which is a ptr_MCV for a particular module. For example,
61+   						 * cl_get_mcv_pointer(0x3) returns AudioManagerMIF[0], which is ptr_AudioManager_MCV.
62+   						 *
63+   						 * Again,
64+   						 * \li ODT[idx] is a ptr_MIF
65+   						 * \li MIF[0] is a ptr_MCV. cl_get_mcv_pointer() returns a ptr_MCV
66+   						 * \li MIF[1] is a ptr_MCT
67+   						 *
68+   						 * Usage:
69+   						 * cl_get_mcv_pointer() retrieves the MCV pointer for particular module. If the module is
70+   						 * not loaded, return zero pointer. Use this before doing peek to ensure that you will get a valid data.
71+   						 *
72+   						 * @param   moduleID (a0)
73+   						 *          ID of the module
74+   						 *
75+   						 * @return (a0)
76+   						 *          __memY void * of the MCV[0]
77+   						 *
78+   						 * @ingroup os_interface
79+   						 *
80+   						 *  Registers used (assembly programmers only):
81+   						 *    a0, a1, b1, i0, i1, nm6, nm7
82+   						 */
83+   						
84+   	 0000				 .extern _cl_get_mcv_pointer
85+   						 
86+   						/** 
87+   						 * @brief mcv peek function.
88+   						 *
89+   						 * Function that peeks a value in MCV for particular module
90+   						 * If module is not loaded routine will return zero.
91+   						 *
92+   						 * @param   moduleID (a0)
93+   						 *          ID of the module
94+   						 *
95+   						 * @param   index (a1)
96+   						 *          MCV index (must be 0x7FF or less)
97+   						 *
98+   						 * @return (a0)
99+   						 *          integer value of the MCV[index]
100+  						 *
101+  						 * @ingroup os_interface
102+  						 *
103+  						 *  Registers used (assembly programmers only):
104+  						 *     a0, a1, b1, i0, i1, nm6, nm7
105+  						 */
106+  	 0000				 .extern _cl_mcv_peek
107+  						
108+  						/**
109+  						 * @brief mcv poke function.
110+  						 *
111+  						 * Function that poke integer value in MCV for particular module.
112+  						 * If module is not loaded poke will be ignored.
113+  						 *
114+  						 * @param   moduleID (a0)
115+  						 *          ID of the module
116+  						 *
117+  						 * @param   index (a1)
118+  						 *          MCV index (must be 0x7FF or less)
119+  						 *
120+  						 * @param   value (b0)
121+  						 *          value that will be written to MCV[index]
122+  						 *
123+  						 * @return
124+  						 *          nothing
125+  						 *
126+  						 * @ingroup os_interface
127+  						 *
128+  						 *  Registers used (assembly programmers only):
129+  						 *     a0, a1, b1, i0, i1, nm6, nm7
130+  						 */
131+  	 0000				 .extern _cl_mcv_poke
132+  						
133+  						/** Request a chunk of X memory with no alignment requirement.
134+  						 *  This function should be called inside of a premalloc module
135+  						 *  entry point. After the OS finishes heap allocations, the pointer
136+  						 *  should be initialized with the address of the requested memory.
137+  						 *
138+  						 *  @param[in] pointer (i0)
139+  						 *             pointer to an X memory pointer in X memory
140+  						 *
141+  						 *  @param[in] size (x0)
142+  						 *             number of words to allocate.
143+  						 *             Assembly programmers only: note that the malloc request modifies register x0.
144+  						 *             Therefore, if malloc requests are performed back to back (such as within a loop) please remember to restore x0 between requests.
145+  						 *
146+  						 *  Registers used (assembly programmers only):
147+  						 *    i1,i6,i7,a0,a3,b3,x0
148+  						 *
149+  						 *  <b>VERY IMPORTANT:</b> this routine, cl_mallocX, clobbers I7, the C stack pointer.
150+  						 *  Although this routine's C wrapper preserves I7, the C developer must be sure
151+  						 *  to preserve I7 if his or her program bypasses the wrapper and calls cl_mallocX
152+  						 *  directly.
153+  						 *
154+  						 *  @ingroup os_interface
155+  						 */
156+  	 0000				  .extern cl_mallocX
157+  						
158+  						/** Request a chunk of Y memory with no alignment requirement.
159+  						 *  This function should be called inside of a premalloc module
160+  						 *  entry point. After the OS successfully finishes heap allocations, the pointer
161+  						 *  contains the address of the requested memory.
162+  						 *
163+  						 *  @param[in] pointer (i0)
164+  						 *             pointer to a Y memory pointer in X memory
165+  						 *
166+  						 *  @param[in] size (x0)
167+  						 *             number of words to allocate
168+  						 *             Assembly programmers only: note that the malloc request modifies register x0.
169+  						 *             Therefore, if malloc requests are performed back to back (such as within a loop) please remember to restore x0 between requests.
170+  						 *
171+  						 *  Registers used (assembly programmers only):
172+  						 *    i1,i6,i7,a0,a3,b3,x0
173+  						 *
174+  						 *  <b>VERY IMPORTANT:</b> this routine, cl_mallocY, clobbers I7, the C stack pointer.
175+  						 *  Although this routine's C wrapper preserves I7, the C developer must be sure
176+  						 *  to preserve I7 if his or her program bypasses the wrapper and calls cl_mallocY
177+  						 *  directly.
178+  						 *
179+  						 *  @ingroup os_interface
180+  						 */
181+  	 0000				  .extern cl_mallocY
182+  						
183+  						/** Request a chunk of XY (L) memory with no alignment requirement.
184+  						 *  This function should be called inside of a premalloc module
185+  						 *  entry point. After the OS successfully finishes heap allocations, the pointer
186+  						 *  contains the address of the requested memory.
187+  						 *
188+  						 *  @param[in] pointer (i0)
189+  						 *             pointer to an XY memory pointer in X memory
190+  						 *
191+  						 *  @param[in] size (x0)
192+  						 *             number of words to allocate
193+  						 *             Assembly programmers only: note that the malloc request modifies register x0.
194+  						 *             Therefore, if malloc requests are performed back to back (such as within a loop) please remember to restore x0 between requests.
195+  						 *
196+  						 *  Registers used (assembly programmers only):
197+  						 *    i1,i6,i7,a0,a3,b3,x0
198+  						 *
199+  						 *  <b>VERY IMPORTANT:</b> this routine, cl_mallocL, clobbers I7, the C stack pointer.
200+  						 *  Although this routine's C wrapper preserves I7, the C developer must be sure
201+  						 *  to preserve I7 if his or her program bypasses the wrapper and calls cl_mallocL
202+  						 *  directly.
203+  						 *
204+  						 *  @ingroup os_interface
205+  						 */
206+  	 0000				  .extern cl_mallocL
207+  						
208+  						/** Request a chunk of X memory aligned on a modulo boundary.
209+  						 *  This function should be called inside of a premalloc module
210+  						 *  entry point. After the OS successfully finishes heap allocations, the pointer
211+  						 *  contains the address of the requested memory.
212+  						 *
213+  						 *  @param[in] pointer (i0)
214+  						 *             pointer to an X memory pointer in X memory
215+  						 *
216+  						 *  @param[in] size (x0)
217+  						 *             number of words to allocate. <b>SIZE MUST BE A POWER OF 2.</b>
218+  						 *             Address of allocated memory is guaranteed to be
219+  						 *             an even multiple of the next power of 2 >= size.
220+  						 *             Assembly programmers only: note that the malloc request modifies register x0.
221+  						 *             Therefore, if malloc requests are performed back to back (such as within a loop) please remember to restore x0 between requests.
222+  						 *
223+  						 *  Registers used (assembly programmers only):
224+  						 *    i1,i6,i7,a0,a3,b3,x0
225+  						 *
226+  						 *  <b>VERY IMPORTANT:</b> this routine, cl_mallocModX, clobbers I7, the C stack pointer.
227+  						 *  Although this routine's C wrapper preserves I7, the C developer must be sure
228+  						 *  to preserve I7 if his or her program bypasses the wrapper and calls cl_mallocModX
229+  						 *  directly.
230+  						 *
231+  						 *  @ingroup os_interface
232+  						 */
233+  	 0000				  .extern cl_mallocModX
234+  						
235+  						/** Request a chunk of Y memory aligned on a modulo boundary.
236+  						 *  This function should be called inside of a premalloc module
237+  						 *  entry point. After the OS successfully finishes heap allocations, the pointer
238+  						 *  contains the address of the requested memory.
239+  						 *
240+  						 *  @param[in] pointer (i0)
241+  						 *             pointer to an X memory pointer in X memory
242+  						 *
243+  						 *  @param[in] size (x0)
244+  						 *             number of words to allocate. <b>SIZE MUST BE A POWER OF 2.</b>
245+  						 *             Address of allocated memory is guaranteed to be
246+  						 *             an even multiple of the next power of 2 >= size.
247+  						 *             Assembly programmers only: note that the malloc request modifies register x0.
248+  						 *             Therefore, if malloc requests are performed back to back (such as within a loop) please remember to restore x0 between requests.
249+  						 *
250+  						 *  Registers used (assembly programmers only):
251+  						 *    i1,i6,i7,a0,a3,b3,x0
252+  						 *
253+  						 *  <b>VERY IMPORTANT:</b> this routine, cl_mallocModY, clobbers I7, the C stack pointer.
254+  						 *  Although this routine's C wrapper preserves I7, the C developer must be sure
255+  						 *  to preserve I7 if his or her program bypasses the wrapper and calls cl_mallocModY
256+  						 *  directly.
257+  						 *
258+  						 *  @ingroup os_interface
259+  						 */
260+  	 0000				  .extern cl_mallocModY
261+  						
262+  						/** Request a chunk of XY (L) memory aligned on a modulo boundary.
263+  						 *  This function should be called inside of a premalloc module
264+  						 *  entry point. After the OS successfully finishes heap allocations, the pointer
265+  						 *  contains the address of the requested memory.
266+  						 *
267+  						 *  @param[in] pointer (i0)
268+  						 *             pointer to an X memory pointer in X memory
269+  						 *
270+  						 *  @param[in] size (x0)
271+  						 *             number of words to allocate. <b>SIZE MUST BE A POWER OF 2.</b>
272+  						 *             Address of allocated memory is guaranteed to be
273+  						 *             an even multiple of the next power of 2 >= size.
274+  						 *             Assembly programmers only: note that the malloc request modifies register x0.
275+  						 *             Therefore, if malloc requests are performed back to back (such as within a loop) please remember to restore x0 between requests.
276+  						 *
277+  						 *  Registers used (assembly programmers only):
278+  						 *    i1,i6,i7,a0,a3,b3,x0
279+  						 *
280+  						 *  <b>VERY IMPORTANT:</b> this routine, cl_mallocModL, clobbers I7, the C stack pointer.
281+  						 *  Although this routine's C wrapper preserves I7, the C developer must be sure
282+  						 *  to preserve I7 if his or her program bypasses the wrapper and calls cl_mallocModL
283+  						 *  directly.
284+  						 *
285+  						 * <b>Note:</b> The use of cl_mallocModL in a .mwproj or .pwproj may require adjustment of DSP Composer properties.
286+  						 * For example, if the maximum cl_mallocModL size is 1024 and the module or primitive is used in a CS48LXX project,
287+  						 * Set File->Properties->Maximum Aligned Heap Required = 1024 in composer.
288+  						 * This sets the heap base on a 1024 boundary. Heap base is not an issue for a .uwproj using cl_mallocModL.
289+  						 *
290+  						 *  @ingroup os_interface
291+  						 */
292+  	 0000				  .extern cl_mallocModL
293+  						
294+  						/**
295+  						 * @brief Sends an unsolicited message to the host.
296+  						 *
297+  						 * @param[in] pPayload (i7) pointer to the first word in the message body, in X memory.
298+  						 *
299+  						 * @param[in] pPayload (i6) size of the message, in words.
300+  						 *
301+  						 * @return (a3) returns nonzero for success and 0 for failure.
302+  						 *
303+  						 *  Modifies: i5, b3, nm7, nm5
304+  						 *
305+  						 * @ingroup os_interface
306+  						 */
307+  	 0000				 .extern cl_send_unsol_msg
308+  						
309+  						/**
310+  						* @brief function used to set or clear a GPO bit
311+  						*
312+  						* This function will work on CS48L10, CS47XXX, and CS485XX but not CS4953X, CS497XX nor CS498XX. (single core only)
313+  						*
314+  						* Note that the host must set bits 12 and 13 of the OS MCV at Kickstart. Example: ucmd 8140000000003000
315+  						*
316+  						* Note also, that the GPIO index must be turned on and direction set to out.
317+  						*
318+  						* Example for GPIO 16
319+  						*
320+  						* Enable (ucmd 8140003D00010000)
321+  						*
322+  						* Set Direction=Out (ucmd 8140003C00010000)
323+  						*
324+  						* Note that ucmd 814HHHHH hhhhhhhh is a "poke-OR"
325+  						*
326+  						* @param[in] gpo_state (a0). gpo_state=1 to set the GPO bit. gpi_state=0 to clear the GPO bit.
327+  						*
328+  						* @param[in] gpo_mask (a1). Bitmask to determine which GPO bit to set or clear. Bitmask = (1 << gpo_index)
329+  						* For example: for GPO 16, which is the LED on the CS47XXX daughter card marked "GPO16," use (0x1<<16) == 0x00010000
330+  						*
331+  						* modifies registers a0,a1,b0,b1
332+  						*
333+  						* @ingroup os_interface
334+  						*/
335+  	 0000				   .extern cl_poke_gpo
336+  						
337+  						/**
338+  						* @brief query the status of a GPI bit
339+  						*
340+  						* This function will work on CS48L10, CS47XXX, and CS485XX but not CS4953X, CS497XX nor CS498XX. (single core only)
341+  						*
342+  						* Note that the host must set bits 12 and 13 of the OS MCV at Kickstart. Example: ucmd 8140000000003000
343+  						*
344+  						* Note also, that the GPIO index must be turned on and direction set to in.
345+  						*
346+  						* Example for GPIO 3:
347+  						*
348+  						*   Enable (ucmd 8140003D00000008)
349+  						*
350+  						*   Set Direction=in (ucmd 8180003Cfffffff7)
351+  						*
352+  						* Note that 814HHHHH hhhhhhhh is a "poke-OR" and 818HHHHH hhhhhhhh is a poke-AND
353+  						*
354+  						* @param[in] gpi_mask (a0). Mask used to determine which GPI to query. For example: for GPI 3,
355+  						*   which is the pushbutton on the CS47XXX daughter card marked "s2," use (1<<3) == 0x00000008
356+  						*
357+  						* @return (a0) returns the state of the GPI. 
358+  						*
359+  						* modifies registers a0,a1,b0,b1
360+  						*
361+  						* @ingroup os_interface
362+  						*/
363+  	 0000				  .extern cl_peek_gpi
364+  						
365+  						/**
366+  						* @brief Register a callback function, to be called when a gpi changes state.
367+  						*
368+  						*  @param[in] function_ptr (i0) =  this function MUST save/restore all modified registers
369+  						*  User callback function may assume that a 32 bit value, with bits set for any gpi
370+  						*  pins that caused the callback function to be called, will be available in a0h.
371+  						*
372+  						*  @param[in] gpio_mask (a0) = bit mask for which GPIO will be monitored for interrupt.
373+  						*  Bit 0 corresponds to GPIO0, bit 1 corresponds to GPIO1 and so on.
374+  						*
375+  						*  @param[in] intlvl_setting(a1) When this is 1, level-based interrupts are set for pins
376+  						*  corresponding to gpio_mask. When this is 0, edge-based interrupts are set for pins
377+  						*  corresponding to gpio_mask.  Note: If intlvl_setting is set to 1, then the library isr code will wait until the irq line
378+  						*  goes back to it's non-active state before clearing the IRQ_STICKY bits and exiting the
379+  						*  isr.  If this period is too long, the user is advised to use edge-based interrupts instead.
380+  						*
381+  						*  @param[in] inthilo_setting(b0) When this is 1, level-based interrupts are active high
382+  						*  and edge-based interrupts are positive edge for pins corresponding to gpio_mask.
383+  						*  When this is 0, level based interrupts are active low and edge-based interrupts are
384+  						*  negative edge for pins corresponding to gpio_mask.
385+  						*
386+  						*  @return (a0) == 1 (success)
387+  						*
388+  						* Modifies: a2, a3, x3
389+  						*
390+  						*  @ingroup os_interface
391+  						*/
392+  	 0000				  .extern cl_os_register_gpi_handler
393+  						
394+  						/*=================================================================*/
395+  						
396+  						/**
397+  						* @brief I2C write command, non-blocking
398+  						*
399+  						* This function works on CS48L10 and CS47XXX, but not CS485XX, CS4953X, CS497XX nor CS498XX.
400+  						*
401+  						* @param[in] i2c_command_word (x2)
402+  						*        Bits  6:0  -- Slave address
403+  						*        Bits 19:8 -- Clock divider value
404+  						*        Bits 22:20 -- Bytes per message
405+  						*
406+  						* @param[in] count_of_message_words (i6)
407+  						*
408+  						* @param[in] pxWriteMsg_Fifo (i0) NOTE: bytes 0x00YYYYYY are used if count==3, 0x0000YYYY if count==2, and 0x000000YY if count==1.
409+  						*
410+  						* @return (b1) error_status. On CS47LXX, {0=No error, 1=Time out error}
411+  						*                            On CS48LXX, {0x0000 0000= No Error,
412+  						*                            0x0000 0001= Illegal I2C transaction issued
413+  						*                            0x0000 0002= IIC NO ACK error
414+  						*                            0x0000 0004= Time out}
415+  						*
416+  						* <b>IMPORTANT: For CS48L2X, CS47L3X, use C platform library instead of DSP Library for I2C operations. </b>
417+  						* Notes: Correct usage model is to issue blocking calls for one time communication
418+  						* as in post-kickstart stage (i2c functions cannot be used at pre-kickstart) and non-blocking calls for periodic transactions as in
419+  						* module block or timer routines.
420+  						*
421+  						*  \code
422+  						*  //Example: send the equivalent of iic_cfg -a 0xa0 -w 00 00 EC, until it succeeds, within the block routine.
423+  						*   if (success==0)
424+  						*  {
425+  						*     g_cmd_word=cl_I2C_Command_Word(0x50,0xF80,3);
426+  						*     g_msgbuf=0x000000EC; //with bytes per message of 0x3, bytes 0x00YYYYYY are used
427+  						*     retval=cl_I2C_Nonblocking_WriteMsg(g_cmd_word,3,&g_msgbuf);
428+  						*     if (retval==0){
429+  						*	    success=1;
430+  						*     }
431+  						*  }
432+  						*  \endcode
433+  						*
434+  						* @ingroup os_interface
435+  						*/
436+  	 0000				  .extern cl_I2C_Nonblocking_WriteMsg
437+  						
438+  						/**
439+  						* @brief I2C read command, non-blocking
440+  						*
441+  						* This function works on CS48L10 and CS47XXX, but not CS485XX, CS4953X, CS497XX nor CS498XX.
442+  						*
443+  						* @param[in] i2c_command_word (x2)
444+  						*        Bits  6:0  -- Slave address
445+  						*        Bits 19:8 -- Clock divider value
446+  						*        Bits 22:20 -- Bytes per message
447+  						*
448+  						* @param[in] count_of_message_words (i6)
449+  						*
450+  						* @param[in] pxReadMsg_Fifo (i0)
451+  						*
452+  						* @return (b1) error_status. On CS47LXX, {0=No error, 1=Time out error}
453+  						*                            On CS48LXX, {0x0000 0000= No Error,
454+  						*                            0x0000 0001= Illegal I2C transaction issued
455+  						*                            0x0000 0002= IIC NO ACK error
456+  						*                            0x0000 0004= Time out}
457+  						*
458+  						* <b>IMPORTANT: For CS48L2X, CS47L3X, use C platform library instead of DSP Library for I2C operations. </b>
459+  						* Notes: Correct usage model is to issue blocking calls for one time communication
460+  						* as in post-kickstart stage (i2c functions cannot be used at pre-kickstart) and non-blocking calls for periodic transactions as in
461+  						* module block or timer routines.
462+  						*
463+  						* @ingroup os_interface
464+  						*/
465+  	 0000				  .extern cl_I2C_Nonblocking_ReadMsg
466+  						
467+  						/**
468+  						* @brief I2C read command, blocking
469+  						*
470+  						* This function works on CS48L10 and CS47XXX, but not CS485XX, CS4953X, CS497XX nor CS498XX.
471+  						*
472+  						* @param[in] i2c_command_word (x2)
473+  						*        Bits  6:0  -- Slave address
474+  						*        Bits 19:8 -- Clock divider value
475+  						*        Bits 22:20 -- Bytes per message
476+  						*
477+  						* @param[in] count_of_message_words (i6)
478+  						*
479+  						* @param[in] time_out_ms (x3) time out in milliseconds
480+  						*
481+  						* @param[in] pxReadMsg_Fifo (i0)
482+  						*
483+  						* @return (b1) error_status. On CS47LXX, {0=No error, 1=Time out error}
484+  						*                            On CS48LXX, {0x0000 0000= No Error,
485+  						*                            0x0000 0001= Illegal I2C transaction issued
486+  						*                            0x0000 0002= IIC NO ACK error
487+  						*                            0x0000 0004= Time out}
488+  						*
489+  						* <b>IMPORTANT: For CS48L2X, CS47L3X, use C platform library instead of DSP Library for I2C operations. </b>
490+  						* Notes: Correct usage model is to issue blocking calls for one time communication
491+  						* as in post-kickstart stage (i2c functions cannot be used at pre-kickstart) and non-blocking calls for periodic transactions as in
492+  						* module block or timer routines.
493+  						*
494+  						* @ingroup os_interface
495+  						*/
496+  	 0000				  .extern cl_I2C_ReadMsg
497+  						
498+  						/**
499+  						* @brief I2C write command, blocking.
500+  						*
501+  						* This function works on CS48L10 and CS47XXX, but not CS485XX, CS4953X, CS497XX nor CS498XX.
502+  						*
503+  						* @param[in] i2c_command_word (x2)
504+  						*        Bits  6:0  -- Slave address
505+  						*        Bits 19:8 -- Clock divider value
506+  						*        Bits 22:20 -- Bytes per message. NOTE: for 3, bytes 0x00YYYYYY are used. For 2, bytes 0x0000YYYY are used and for 1, bytes 0x000000YY are used.
507+  						*
508+  						* @param[in] count_of_message_words (i6)
509+  						*
510+  						* @param[in] time_out_ms (x3) time out in milliseconds
511+  						*
512+  						* @param[in] pxWriteMsg_Fifo (i0)
513+  						*
514+  						* @return (b1) error_status. On CS47LXX, {0=No error, 1=Time out error}
515+  						*                            On CS48LXX, {0x0000 0000= No Error,
516+  						*                            0x0000 0001= Illegal I2C transaction issued
517+  						*                            0x0000 0002= IIC NO ACK error
518+  						*                            0x0000 0004= Time out}
519+  						*
520+  						* <b>IMPORTANT: For CS48L2X, CS47L3X, use C platform library instead of DSP Library for I2C operations. </b>
521+  						* Notes: Correct usage model is to issue blocking calls for one time communication
522+  						* as in post-kickstart stage (i2c functions cannot be used at pre-kickstart) and non-blocking calls for periodic transactions as in
523+  						* module block or timer routines.
524+  						*
525+  						* \code
526+  						*   //example: send the equivalent of iic_cfg -a 0xa0 -w 00 00 AC
527+  						*   int g_cmd_word=cl_I2C_Command_Word(0x50,0xF80,3);
528+  						*   int g_msgbuf=0x000000ac; //note that with bytes per message==3, bytes 0x00YYYYYY are used.
529+  						*	cl_I2C_WriteMsg(g_cmd_word,3,100,&g_msgbuf);
530+  						* \endcode
531+  						*
532+  						* @ingroup os_interface
533+  						*/
534+  	 0000				  .extern cl_I2C_WriteMsg
535+  						
536+  						
537+  						/**
538+  						* @brief Create an I2C command word to be used in cl_I2C_ReadMsg,
539+  						* cl_I2C_WriteMsg, cl_I2C_Nonblocking_ReadMsg, cl_I2C_Nonblocking_WriteMsg
540+  						*
541+  						* @param[in] i2c_address (a0) the 7-bit address of the i2c device.
542+  						*
543+  						* @param[in] i2c_clock_divider (a1) divide the Cirrus DSP's core clock (HCLK/(8*(divider+1)) )
544+  						*
545+  						* @param[in] bytes_per_message (b0) count in bytes, for the payload.
546+  						*
547+  						* @return (x2) formatted IIC Command word
548+  						*        Bits  6:0  -- 7-bit Slave address: If the intended address is 0xA0, the seven bit address is 0x50.
549+  						*        Bits 19:8 -- Clock divider value
550+  						*        Bits 22:20 -- Bytes per message: NOTE: for 3, bytes 0x00YYYYYY are used. For 2, bytes 0x0000YYYY are used and for 1, bytes 0x000000YY are used.
551+  						*
552+  						* assembly programmers only: caller must set mr_sr=(4)
553+  						*
554+  						* <b>IMPORTANT: For CS48L2X, CS47L3X, use C platform library instead of DSP Library for I2C operations. </b>
555+  						*
556+  						* @ingroup os_interface
557+  						*/
558+  	 0000				  .extern cl_I2C_Command_Word
559+  						
560+  						/**
561+  						* @brief: function to send stop on the IIC line
562+  						* and reset the OS_IIC_Msg_Busy and Error status to 0
563+  						*
564+  						* @return none
565+  						*
566+  						* <b>IMPORTANT: For CS48L2X, CS47L3X, use C platform library instead of DSP Library for I2C operations. </b>
567+  						*
568+  						* @ingroup os_interface
569+  						*/
570+  	 0000				  .extern cl_I2C_Abort_Message
571+  						
572+  						/*=================================================================*/
573+  						
574+  						/**
575+  						 * @brief Clears the nm0-nm7 registers.
576+  						 *
577+  						 * Sets these registers to 0, and sets mr_sr=0x4, when called from C.
578+  						 *
579+  						 * @param (none)
580+  						 *
581+  						 * @return (none)
582+  						 *
583+  						 * modifies resources: nm0-nm7 (and sets mr_sr=4 when called from C)
584+  						 *
585+  						 * @ingroup os_interface
586+  						 */
587+  	 0000				  .extern cl_clearNM0_7
588+  						
589+  						/*=================================================================*/
590+  						
591+  						/** @def BRICK_SIZE
592+  						 * size of one block of audio data.
593+  						 * @ingroup os_interface
594+  						 */
595+  							.if !defined(BRICK_SIZE)
596+  	 0010				BRICK_SIZE .equ 16
597+  							.endif		
598+  						
599+  						
600+  						/** @def NUMBER_OF_IO_CHANNELS
601+  						 * number of internal PCM channels.
602+  						 * @ingroup os_interface
603+  						 */
604+  							.if !defined(MAX_HARDWARE_DSP_CHANNELS_FOR_ANY_CIRRUS_PLATFORM)
605+  	 0010				MAX_HARDWARE_DSP_CHANNELS_FOR_ANY_CIRRUS_PLATFORM .equ 16
606+  							.endif
607+  						
608+  						/** Input output buffers
609+  						 * a set of pointers to the current brick buffer, one per channel.
610+  						 * data size: 1
611+  						 * memory zone X
612+  						 * @ingroup os_interface
613+  						 */
614+  						
615+  	 0000					.extern ___X_BY_IOBUFFER_PTRS
616+  						
617+  						/** Variable that has input mode for all processing blocks.
618+  						 * Change mode if you add or remove channels (for the benefit of down-stream modules)
619+  						 * data size: 1
620+  						 * memory zone X
621+  						 * @ingroup os_interface
622+  						 */
623+  						
624+  	 0000					.extern ___X_VX_PPM_INPUTMODE
625+  						/** Variable that has input channels for all processing blocks.
626+  						 * Change mask if you add or remove channels (for the benefit of down-stream modules)
627+  						 * data size: 1
628+  						 * memory zone X
629+  						 * @ingroup os_interface
630+  						 */
631+  							
632+  	 0000					.extern ___X_VX_PPM_INPUT_CHANNELS
633+  						
634+  						
635+  						/** Variable that has output mode for all processing blocks.
636+  						 * Change mode if you add or remove channels (for the benefit of down-stream modules)
637+  						 * data size: 1
638+  						 * memory zone X
639+  						 * @ingroup os_interface
640+  						 */
641+  							
642+  	 0000					.extern ___X_VX_PPM_OUTPUTMODE
643+  						
644+  						/** Variable that has output channels mask for all processing blocks.
645+  						 * Change mask if you add or remove channels (for the benefit of down-stream modules)
646+  						 * data size: 1
647+  						 * memory zone X
648+  						 * @ingroup os_interface
649+  						 */
650+  						
651+  	 0000					.extern ___X_VX_PPM_OUTPUT_CHANNELS
652+  						/** Variable that indicates audio underflow in the DSP
653+  						 * data size: 1
654+  						 * memory zone X
655+  						 * @ingroup os_interface
656+  						 */
657+  												
658+  	 0000					.extern ___X_VX_UNDERFLOW
659+  						
660+  						
661+  						
662+  						
663+  						
664+  						
665+  						/** __X_VX_PPM_INPUT_CHANNELS and __X_VX_PPM_OUTPUT_CHANNELS are bitfield representations of the
666+  						 * Input and Output Modes. Valid_Channels is initially a copy of __X_VX_PPM_INPUT_CHANNELS, but
667+  						 * is modified by Modules as channels are added or removed. These variables are set by the OS
668+  						 * and exist only as part of the MPM/PPM Frame Data.
669+  						 *  __X_VX_PPM_VALID_CHANNELS specifies which of the 16 channels contain valid data and should be
670+  						 * operated on by a Module. Each bit in __X_VX_PPM_VALID_CHANNELS corresponds to a single channel,
671+  						 * with a 1 signifying valid data and a 0 signifying no data. __X_VX_PPM_VALID_CHANNELS must be
672+  						 * modified by a Module when it adds or removes channels. Consider a virtualizer that transforms 5.1
673+  						 * channels into a single stereo pair. Upon entering the virtualizer Module, __X_VX_PPM_VALID_CHANNELS
674+  						 * might contain the value 0x009F (10011111b): a total of 6 bits set to one corresponding to the standard
675+  						 * L, C, R, Ls, Rs and LFE channels. The Module performs the virtualization, sets __X_VX_PPM_VALID_CHANNELS
676+  						 * to 0x0005 (00000101b: two bits corresponding to L and R) and clears the 16-samples in the C, Ls, Rs,
677+  						 * and LFE channel buffers. Subsequent Modules would then operate only on the new set of valid channels.
678+  						 */
679+  						
680+  						/** Variable that has input channels mask for the first processing block (decoder).
681+  						 * This variable is controlled by OS and shoild not be changed.
682+  						 * @ingroup os_interface
683+  						 */
684+  						
685+  						/** Bit map used to determine what channels are valid coming in current processing block.
686+  						 * Change this map if you add or remove channels (for the benefit of down-stream modules)
687+  						 * @ingroup os_interface
688+  						 */
689+  						
690+  	 0000					.extern ___X_VX_PPM_VALID_CHANNELS
691+  						
692+  						
693+  						/** Current sample rate
694+  						 * data size: 1
695+  						 * memory zone X
696+  						
697+  						 * @ingroup os_interface
698+  						 */
699+  	 0000				 .extern ___X_VX_PPM_SAMPLERATE
700+  							
701+  						/** @brief Flag to initiate malloc operations.
702+  						 * Set X_VX_NEXTFRM_REINIT_REQ to a non-zero value to initiate a fresh malloc of the
703+  						 * entire system at the next frame transition. Setting X_VX_NEXTFRM_REINIT_REQ triggers a
704+  						 * premalloc + postmalloc at the next frame transition. Setting of this flag is not required for
705+  						 * the malloc on startup. A module can set the X_VX_NEXTFRM_REINIT_REQ at any time.
706+  						 *
707+  						 * Notes and typical usage scenario:
708+  						 * Typically every module's post-kick start routine will set X_VX_NextFrm_Reinit_Req to 1
709+  						 * and a module specific malloc done flag to 0.
710+  						 * Post-kick routines are called from the OS once each time when the control goes
711+  						 * to App_Restart before dropping down in a continuous background call loop.
712+  						 *
713+  						 * The OS does the following, in order, when responding to a X_VX_NEXTFRM_REINIT_REQ request:
714+  						 *  call pre-malloc entry point for each module
715+  						 *  do mallocations
716+  						 *  call post-malloc entry point for each module
717+  						 *  clear X_VX_NextFrm_Renint_Req variable (set it to 0)
718+  						 *
719+  						 * An individual module can set X_VX_NextFrm_Reinit_Req at any point (e.g. block,background,frame) if the
720+  						 * module detects a change in parameters that need to be addressed with change in mallocations.
721+  						 * OS will only act upon the request at the next frame boundary.
722+  						 *
723+  						 * Related notes:
724+  						 * a reinit request will trigger pre and post malloc, but not postkick.  Postkick is called when a
725+  						 * stream level change occurs, and soft reset is required, as such, modules must be careful that all
726+  						 * the necessary requests for heap are done in premalloc and not in postkick
727+  						 *
728+  						 * @ingroup os_interface
729+  						 */
730+  	 0000					.extern ___X_VX_NEXTFRM_REINIT_REQ
731+  						
732+  						/** Flag to detect heap reinitialization.
733+  						 * Check this flag for a non-zero value, which indicates that re-malloc has occured.
734+  						 * module.
735+  						 * data size: 1
736+  						 * memory zone X
737+  						 * @ingroup os_vars
738+  						 */
739+  						
740+  	 0000					.extern ___X_VX_REINIT
741+  						
742+  						/** Number of audio samples presented per brick (block) entry point to modules running in the post processing modules (PPM) overlay.
743+  						 * data size: 1
744+  						 * memory zone Y
745+  						 * @ingroup os_vars
746+  						 */
747+  	 0000					.extern	___X_VY_BRICK_SIZE
748+  						
749+  						/** @defgroup tempbufs Temporary Buffers
750+  						* Temporary buffers which can be used within block routines.
751+  						*
752+  						*  Contents of temp buffers are not preserved between block routine calls.
753+  						*
754+  						*  Note that X_BL_* buffers are the same data space identified by
755+  						*           * X_BX_* and
756+  						*           * X_BY_* buffers.
757+  						*
758+  						*  @ingroup os_interface
759+  						*/
760+  						
761+  						
762+  						/** a temporary buffer in XY memory of size 256.
763+  						 *  Available for the duration of one foreground entry point.
764+  						 * @ingroup tempbufs
765+  						 */
766+  	 0000					.extern ___X_BL_TEMPBUFF
767+  						/** a temporary buffer in Y memory of size 256. 
768+  						 *  Available for the duration of one foreground entry point.
769+  						 * @ingroup tempbufs
770+  						 */
771+  	 0000					.extern ___X_BY_TEMPBUFF
772+  						/** a temporary buffer in X memory of size 256. 
773+  						 *  Available for the duration of one foreground entry point.
774+  						 * @ingroup tempbufs
775+  						 */
776+  	 0000					.extern ___X_BX_TEMPBUFF
777+  						
778+  						/** a temporary buffer of size 16 (temp buffer is number 0 of buffers[1..15]) in XY memory.
779+  						 *  Available for the duration of one foreground entry point.
780+  						 * @ingroup tempbufs
781+  						 */
782+  	 0000				    .extern ___X_BL_TEMPBUFF0
783+  						
784+  						/** a temporary buffer of size 16 (temp buffer is number 0 of buffers[0..15]) in Y memory.
785+  						 *  Available for the duration of one foreground entry point.
786+  						 * @ingroup tempbufs
787+  						 */
788+  	 0000				    .extern ___X_BY_TEMPBUFF0
789+  						/** a temporary buffer of size 16 (temp buffer is number 0 of buffers[0..15]) in X memory.
790+  						 *  Available for the duration of one foreground entry point.
791+  						 * @ingroup tempbufs
792+  						 */
793+  	 0000				    .extern ___X_BX_TEMPBUFF0
794+  						
795+  						/** a temporary buffer of size 16 (temp buffer is number 1 of buffers[1..15]) in XY memory.
796+  						 *  Available for the duration of one foreground entry point.
797+  						 * @ingroup tempbufs
798+  						 */
799+  	 0000				    .extern ___X_BL_TEMPBUFF1
800+  						/** a temporary buffer of size 16 (temp buffer is number 1 of buffers[0..15]) in Y memory.
801+  						 *  Available for the duration of one foreground entry point.
802+  						 * @ingroup tempbufs
803+  						 */
804+  	 0000				    .extern ___X_BY_TEMPBUFF1
805+  						/** a temporary buffer of size 16 (temp buffer is number 1 of buffers[0..15]) in X memory.
806+  						 *  Available for the duration of one foreground entry point.
807+  						 * @ingroup tempbufs
808+  						 */
809+  	 0000				    .extern ___X_BX_TEMPBUFF1
810+  						
811+  						/** a temporary buffer of size 16 (temp buffer is number 2 of buffers[1..15]) in XY memory.
812+  						 *  Available for the duration of one foreground entry point.
813+  						 * @ingroup tempbufs
814+  						 */
815+  	 0000				    .extern ___X_BL_TEMPBUFF2
816+  						/** a temporary buffer of size 16 (temp buffer is number 2 of buffers[0..15]) in Y memory.
817+  						 *  Available for the duration of one foreground entry point.
818+  						 * @ingroup tempbufs
819+  						 */
820+  	 0000				    .extern ___X_BY_TEMPBUFF2
821+  						/** a temporary buffer of size 16 (temp buffer is number 2 of buffers[0..15]) in X memory.
822+  						 *  Available for the duration of one foreground entry point.
823+  						 * @ingroup tempbufs
824+  						 */
825+  	 0000				    .extern ___X_BX_TEMPBUFF2
826+  						
827+  						/** a temporary buffer of size 16 (temp buffer is number 3 of buffers[1..15]) in XY memory.
828+  						 *  Available for the duration of one foreground entry point.
829+  						 * @ingroup tempbufs
830+  						 */
831+  	 0000				    .extern ___X_BL_TEMPBUFF3
832+  						/** a temporary buffer of size 16 (temp buffer is number 3 of buffers[0..15]) in Y memory.
833+  						 *  Available for the duration of one foreground entry point.
834+  						 * @ingroup tempbufs
835+  						 */
836+  	 0000				    .extern ___X_BY_TEMPBUFF3
837+  						/** a temporary buffer of size 16 (temp buffer is number 3 of buffers[0..15]) in X memory.
838+  						 *  Available for the duration of one foreground entry point.
839+  						 * @ingroup tempbufs
840+  						 */
841+  	 0000				    .extern ___X_BX_TEMPBUFF3
842+  						
843+  						/** a temporary buffer of size 16 (temp buffer is number 4 of buffers[1..15]) in XY memory.
844+  						 *  Available for the duration of one foreground entry point.
845+  						 * @ingroup tempbufs
846+  						 */
847+  	 0000				    .extern ___X_BL_TEMPBUFF4
848+  						/** a temporary buffer of size 16 (temp buffer is number 4 of buffers[0..15]) in Y memory.
849+  						 *  Available for the duration of one foreground entry point.
850+  						 * @ingroup tempbufs
851+  						 */
852+  	 0000				    .extern ___X_BY_TEMPBUFF4
853+  						/** a temporary buffer of size 16 (temp buffer is number 4 of buffers[0..15]) in X memory.
854+  						 *  Available for the duration of one foreground entry point.
855+  						 * @ingroup tempbufs
856+  						 */
857+  	 0000				    .extern ___X_BX_TEMPBUFF4
858+  						
859+  						/** a temporary buffer of size 16 (temp buffer is number 5 of buffers[1..15]) in XY memory.
860+  						 *  Available for the duration of one foreground entry point.
861+  						 * @ingroup tempbufs
862+  						 */
863+  	 0000				    .extern ___X_BL_TEMPBUFF5
864+  						/** a temporary buffer of size 16 (temp buffer is number 5 of buffers[0..15]) in Y memory.
865+  						 *  Available for the duration of one foreground entry point.
866+  						 * @ingroup tempbufs
867+  						 */
868+  	 0000				    .extern ___X_BY_TEMPBUFF5
869+  						/** a temporary buffer of size 16 (temp buffer is number 5 of buffers[0..15]) in X memory.
870+  						 *  Available for the duration of one foreground entry point.
871+  						 * @ingroup tempbufs
872+  						 */
873+  	 0000				    .extern ___X_BX_TEMPBUFF5
874+  						
875+  						/** a temporary buffer of size 16 (temp buffer is number 6 of buffers[1..15]) in XY memory.
876+  						 *  Available for the duration of one foreground entry point.
877+  						 * @ingroup tempbufs
878+  						 */
879+  						
880+  	 0000				    .extern ___X_BL_TEMPBUFF6
881+  						/** a temporary buffer of size 16 (temp buffer is number 6 of buffers[0..15]) in Y memory.
882+  						 *  Available for the duration of one foreground entry point.
883+  						 * @ingroup tempbufs
884+  						 */
885+  	 0000				    .extern ___X_BY_TEMPBUFF6
886+  						/** a temporary buffer of size 16 (temp buffer is number 6 of buffers[0..15]) in X memory.
887+  						 *  Available for the duration of one foreground entry point.
888+  						 * @ingroup tempbufs
889+  						 */
890+  	 0000				    .extern ___X_BX_TEMPBUFF6
891+  						
892+  						/** a temporary buffer of size 16 (temp buffer is number 7 of buffers[1..15]) in XY memory.
893+  						 *  Available for the duration of one foreground entry point.
894+  						 * @ingroup tempbufs
895+  						 */
896+  	 0000				    .extern __X_BL_TEMPBUFF7
897+  						/** a temporary buffer of size 16 (temp buffer is number 7 of buffers[0..15]) in Y memory.
898+  						 *  Available for the duration of one foreground entry point.
899+  						 * @ingroup tempbufs
900+  						 */
901+  	 0000				    .extern ___X_BY_TEMPBUFF7
902+  						/** a temporary buffer of size 16 (temp buffer is number 7 of buffers[0..15]) in X memory.
903+  						 *  Available for the duration of one foreground entry point.
904+  						 * @ingroup tempbufs
905+  						 */
906+  	 0000				    .extern ___X_BX_TEMPBUFF7
907+  						
908+  						/** a temporary buffer of size 16 (temp buffer is number 8 of buffers[1..15]) in XY memory.
909+  						 *  Available for the duration of one foreground entry point.
910+  						 * @ingroup tempbufs
911+  						 */
912+  	 0000				    .extern ___X_BL_TEMPBUFF8
913+  						/** a temporary buffer of size 16 (temp buffer is number 8 of buffers[0..15]) in Y memory.
914+  						 *  Available for the duration of one foreground entry point.
915+  						 * @ingroup tempbufs
916+  						 */
917+  	 0000				    .extern ___X_BY_TEMPBUFF8
918+  						/** a temporary buffer of size 16 (temp buffer is number 8 of buffers[0..15]) in X memory.
919+  						 *  Available for the duration of one foreground entry point.
920+  						 * @ingroup tempbufs
921+  						 */
922+  	 0000				    .extern ___X_BX_TEMPBUFF8
923+  						
924+  						/** a temporary buffer of size 16 (temp buffer is number 9 of buffers[1..15]) in XY memory.
925+  						 *  Available for the duration of one foreground entry point.
926+  						 * @ingroup tempbufs
927+  						 */
928+  	 0000				    .extern ___X_BL_TEMPBUFF9
929+  						/** a temporary buffer of size 16 (temp buffer is number 9 of buffers[0..15]) in Y memory.
930+  						 *  Available for the duration of one foreground entry point.
931+  						 * @ingroup tempbufs
932+  						 */
933+  	 0000				    .extern ___X_BY_TEMPBUFF9
934+  						/** a temporary buffer of size 16 (temp buffer is number 9 of buffers[0..15]) in X memory.
935+  						 *  Available for the duration of one foreground entry point.
936+  						 * @ingroup tempbufs
937+  						 */
938+  	 0000				    .extern ___X_BX_TEMPBUFF9
939+  						
940+  						/** a temporary buffer of size 16 (temp buffer is number 10 of buffers[1..15]) in XY memory.
941+  						 *  Available for the duration of one foreground entry point.
942+  						 * @ingroup tempbufs
943+  						 */
944+  	 0000				    .extern ___X_BL_TEMPBUFF10
945+  						/** a temporary buffer of size 16 (temp buffer is number 10 of buffers[0..15]) in Y memory.
946+  						 *  Available for the duration of one foreground entry point.
947+  						 * @ingroup tempbufs
948+  						 */
949+  	 0000				    .extern ___X_BY_TEMPBUFF10
950+  						/** a temporary buffer of size 16 (temp buffer is number 10 of buffers[0..15]) in X memory.
951+  						 *  Available for the duration of one foreground entry point.
952+  						 * @ingroup tempbufs
953+  						 */
954+  	 0000				    .extern ___X_BX_TEMPBUFF10
955+  						
956+  						/** a temporary buffer of size 16 (temp buffer is number 11 of buffers[1..15]) in XY memory.
957+  						 *  Available for the duration of one foreground entry point.
958+  						 * @ingroup tempbufs
959+  						 */
960+  	 0000				    .extern ___X_BL_TEMPBUFF11
961+  						/** a temporary buffer of size 16 (temp buffer is number 11 of buffers[0..15]) in Y memory.
962+  						 *  Available for the duration of one foreground entry point.
963+  						 * @ingroup tempbufs
964+  						 */
965+  	 0000				    .extern ___X_BY_TEMPBUFF11
966+  						/** a temporary buffer of size 16 (temp buffer is number 11 of buffers[0..15]) in X memory.
967+  						 *  Available for the duration of one foreground entry point.
968+  						 * @ingroup tempbufs
969+  						 */
970+  	 0000				    .extern ___X_BX_TEMPBUFF11
971+  						
972+  						/** a temporary buffer of size 16 (temp buffer is number 12 of buffers[1..15]) in XY memory.
973+  						 *  Available for the duration of one foreground entry point.
974+  						 * @ingroup tempbufs
975+  						 */
976+  	 0000				    .extern ___X_BL_TEMPBUFF12
977+  						/** a temporary buffer of size 16 (temp buffer is number 12 of buffers[0..15]) in Y memory.
978+  						 *  Available for the duration of one foreground entry point.
979+  						 * @ingroup tempbufs
980+  						 */
981+  	 0000				    .extern ___X_BY_TEMPBUFF12
982+  						/** a temporary buffer of size 16 (temp buffer is number 12 of buffers[0..15]) in X memory.
983+  						 *  Available for the duration of one foreground entry point.
984+  						 * @ingroup tempbufs
985+  						 */
986+  	 0000				    .extern ___X_BX_TEMPBUFF12
987+  						
988+  						/** a temporary buffer of size 16 (temp buffer is number 13 of buffers[1..15]) in XY memory.
989+  						 *  Available for the duration of one foreground entry point.
990+  						 * @ingroup tempbufs
991+  						 */
992+  	 0000				    .extern ___X_BL_TEMPBUFF13
993+  						/** a temporary buffer of size 16 (temp buffer is number 13 of buffers[0..15]) in Y memory.
994+  						 *  Available for the duration of one foreground entry point.
995+  						 * @ingroup tempbufs
996+  						 */
997+  	 0000				    .extern ___X_BY_TEMPBUFF13
998+  						/** a temporary buffer of size 16 (temp buffer is number 13 of buffers[0..15]) in X memory.
999+  						 *  Available for the duration of one foreground entry point.
1000+ 						 * @ingroup tempbufs
1001+ 						 */
1002+ 	 0000				    .extern ___X_BX_TEMPBUFF13
1003+ 						
1004+ 						/** a temporary buffer of size 16 (temp buffer is number 14 of buffers[1..15]) in XY memory.
1005+ 						 *  Available for the duration of one foreground entry point.
1006+ 						 * @ingroup tempbufs
1007+ 						 */
1008+ 	 0000				    .extern ___X_BL_TEMPBUFF14
1009+ 						/** a temporary buffer of size 16 (temp buffer is number 14 of buffers[0..15]) in Y memory.
1010+ 						 *  Available for the duration of one foreground entry point.
1011+ 						 * @ingroup tempbufs
1012+ 						 */
1013+ 	 0000				    .extern ___X_BY_TEMPBUFF14
1014+ 						/** a temporary buffer of size 16 (temp buffer is number 14 of buffers[0..15]) in X memory.
1015+ 						 *  Available for the duration of one foreground entry point.
1016+ 						 * @ingroup tempbufs
1017+ 						 */
1018+ 	 0000				    .extern ___X_BX_TEMPBUFF14
1019+ 						
1020+ 						/** a temporary buffer of size 16 (temp buffer is number 15 of buffers[1..15]) in XY memory.
1021+ 						 *  Available for the duration of one foreground entry point.
1022+ 						 * @ingroup tempbufs
1023+ 						 */
1024+ 	 0000					.extern ___X_BL_TEMPBUFF15
1025+ 						/** a temporary buffer of size 16 (temp buffer is number 15 of buffers[0..15]) in Y memory.
1026+ 						 *  Available for the duration of one foreground entry point.
1027+ 						 * @ingroup tempbufs
1028+ 						 */
1029+ 	 0000					.extern ___X_BY_TEMPBUFF15
1030+ 						/** a temporary buffer of size 16 (temp buffer is number 15 of buffers[0..15]) in X memory.
1031+ 						 *  Available for the duration of one foreground entry point.
1032+ 						 * @ingroup tempbufs
1033+ 						 */
1034+ 	 0000					.extern ___X_BX_TEMPBUFF15
1035+ 						
1036+ 						/*======================================================================*/
1037+ 							
1038+ 						  /**
1039+ 						  * @brief Check the busy state of the I2C bus.
1040+ 						  *
1041+ 						  * @return (a0) the busy state of the i2c bus. 0==not busy. 1==busy.
1042+ 						  *
1043+ 						  *  @ingroup os_interface
1044+ 						  */
1045+ 	 0000				  .extern cl_get_i2c_msg_busy
1046+ 						
1047+ 						  /**
1048+ 						  * @brief Check the error code for the most recent I2C command issued.
1049+ 						  *
1050+ 						  * @return (a0) 0x0000 0000     No Error
1051+ 						  *              0x0000 0001     Illegal IIC Transaction issued. Trying to do IIC Write / Read
1052+ 						  *                                 when SCP is not configured for IIC master and not coming from
1053+ 						  *                                 master boot
1054+ 						  *              0x0000 0002     IIC NO ACK Error
1055+ 						  *              0x0000 0004     Time-out error (in case of blocking IIC calls)
1056+ 						  *
1057+ 						  *  @ingroup os_interface
1058+ 						  */
1059+ 	 0000				  .extern cl_get_i2c_msg_error
1060+ 						
1061+ 						  /**
1062+ 						  * @brief Check the I2C pending writes count
1063+ 						  *
1064+ 						  * @return (a0) I2C Message pending reads count
1065+ 						  *
1066+ 						  *  @ingroup os_interface
1067+ 						  */
1068+ 	 0000				  .extern cl_get_i2c_msg_pending_writes
1069+ 						
1070+ 						  /**
1071+ 						  * @brief Check the I2C pending reads count
1072+ 						  *
1073+ 						  * @return (a0) I2C Message pending reads count
1074+ 						  *
1075+ 						  *  @ingroup os_interface
1076+ 						  */
1077+ 	 0000				  .extern cl_get_i2c_msg_pending_reads
1078+ 						
1079+ 						  /**
1080+ 						  * @brief Check the I2C Message FIFO pointer
1081+ 						  *
1082+ 						  * @return (a0) the I2C Message FIFO pointer
1083+ 						  *
1084+ 						  * assembly programmers only: Modifies register a0, and the "a" status register.
1085+ 						  *
1086+ 						  *  @ingroup os_interface
1087+ 						  */
1088+ 	 0000				  .extern cl_get_i2c_msg_fifo_ptr
1089+ 						
1090+ 						  /**
1091+ 						  * @brief Check the I2C message current command word
1092+ 						  *
1093+ 						  * @return (a0) the I2C message current command word
1094+ 						  *
1095+ 						  *  @ingroup os_interface
1096+ 						  */
1097+ 	 0000				  .extern cl_get_i2c_cmd_word
1098+ 						
1099+ 						
1100+ 						  .endif
1101+  >> end of include file: C:/CirrusDSP/include/dsplib/os_asm.h
1101+  >> continuing with file: D:/ra150/projekat/resenje/projekat_module/src/projekat_module_main.a
8     						.include "projekat_module_mcv.h"
8      >> open include file: D:/ra150/projekat/resenje/projekat_module/gen/inc/projekat_module_mcv.h
1+    						/*
2+    						 * This file is automatically generated by CLIDE
3+    						 *
4+    						 * MCV (Module Control Vector)
5+    						 */
6+    						.include "dsplib/meter_asm.h" 
6+     >> open include file: C:/CirrusDSP/include/dsplib/meter_asm.h
1+    							.if !defined(_meter_h_)
2+    	 0000				_meter_h_
3+    						
4+    						METER_T .struct
5+    						RMS .dw 0			#fract(1.31)
6+    						RMS_HOLD .dw 0		#fract(1.31)
7+    						PEAK .dw 0			#fract(1.31)
8+    						PEAK_HOLD .dw 0		#fract(1.31)
9+    							.endstruct
10+   						
11+   						(null)11+    >> end of include file: C:/CirrusDSP/include/dsplib/meter_asm.h
11+    >> continuing with file: D:/ra150/projekat/resenje/projekat_module/gen/inc/projekat_module_mcv.h
7+    						.include "dsplib/response_asm.h"
7+     >> open include file: C:/CirrusDSP/include/dsplib/response_asm.h
1+    							.if !defined(_response_h_)
2+    	 0000				_response_h_
3+    						
4+    						BIQUAD_T .struct
5+    						COEF_A1 .dw 0			#fract(2.30)
6+    						COEF_A2 .dw 0			#fract(2.30)
7+    						COEF_B0 .dw 1			#fract(3.29)
8+    						COEF_B1 .dw 0			#fract(3.29)
9+    						COEF_B2 .dw 0			#fract(3.29)
10+   							.endstruct
11+   						
12+   						RESPONSE_T .struct
13+   						PRE .dw 0			#fract(7.25)
14+   						POST .dw 0			#fract(7.25)
15+   							.rept %i = 0,2
16+   						BIQUAD_%i BIQUAD_T		#struct
17+    >> start of macro: .rept
1+    						BIQUAD_0 BIQUAD_T		#struct
2+    						BIQUAD_1 BIQUAD_T		#struct
3+    						BIQUAD_2 BIQUAD_T		#struct
4+    						
17+   							.endm
18+   							.endstruct
19+   							
20+   							.endif21+   						(null)21+    >> end of include file: C:/CirrusDSP/include/dsplib/response_asm.h
21+    >> continuing with file: D:/ra150/projekat/resenje/projekat_module/gen/inc/projekat_module_mcv.h
8+    						
9+    	 0001				isDefined	 .equ 	 1
10+   						
11+   						MCV_T	.struct
12+   						enable .dw 0	 # bool	non-zero to enable this function
13+   						input_gain .dw 0	 #fract(1.31)
14+   							.endstruct
15+   						
16+   						
17+   	 0000				STRUCTURE_INITIALIZATION_STRNG .equ "0x1, 0x50c335d3"
18+    >> end of include file: D:/ra150/projekat/resenje/projekat_module/gen/inc/projekat_module_mcv.h
18+    >> continuing with file: D:/ra150/projekat/resenje/projekat_module/src/projekat_module_main.a
9     						.include "p_function.a"
9      >> open include file: D:/ra150/projekat/resenje/projekat_module/src/p_function.a
1+    	 0000					.extern _coefficients
2+    	 0000					.extern _gain2
3+    	 0000					.extern _input_gain
4+    	 0000					.extern _p
5+    	 0000					.extern _sampleBuffer
6+    	 0000					.extern _x_history1
7+    	 0000					.extern _x_history2
8+    	 0000					.extern _x_history3
9+    	 0000					.extern _y_history1
10+   	 0000					.extern _y_history2
11+   	 0000					.extern _y_history3
12+   	 0000					.extern _second_order_IIR
13+   	 0000					.public _p_function
14+   							 .code_ovly
14+    >> start of macro: .code_ovly
1+    									seg_single , "CODE_OVLY", CODE
1+     >> start of macro: seg_single
1+    						  .if ( "" != "" ) & defined( ___SegStart_CODE_ )
2+    						    segment
3+    						  .else
4+    						    segment "CODE_OVLY"
5+    							.if "" != ""
6+    						___SegStart_CODE_
7+    							.endif
8+    						  .endif
9+    							#RememberSegmentType
10+    >> end of macro: seg_single
2+     >> end of macro: .code_ovly
15+   						
16+   	 0000				_p_function:			
17+   							#xmem[i7] = i7			
18+   							#i7 += 1			
19+   							#i7 = i7 + (0x1)			 
20+   	 0000				cline_90_0:			
21+   	 0000	 A0050000		i0 = (0) + (_sampleBuffer + 0)			
22+   	 0001	 B0440000		xmem[_p + 0] = i0			
23+   	 0002				cline_93_0:			 
24+   							#i0 = i7 - (0x1)			 
25+   	 0002	 00004DC0		a0 = 0			 
26+   							#xmem[i0] = a0h			
27+   	 0003	 81000075		do (0x10), label_end_92			
28+   	 0004				cline_95_0:			
29+   	 0004				label_begin_92:			
30+   	 0004	 B0040000		i0 = xmem[_p + 0]			
31+   	 0005	 80840000		x0 = ymem[_input_gain + 0]			
32+   	 0006	 81140000		x1 = xmem[i0]			
33+   	 0007	 A0050000		i0 = (0) + (_p)			
34+   	 0008	 B0140000		i0 = xmem[i0]			
35+   	 0009	 00002020		a0 = x1 * x0			
36+   	 000A	 88540000		xmem[i0] = a0			
37+   	 000B				cline_98_0:			
38+   	 000B	 B0040000		i0 = xmem[_p + 0]			 
39+   	 000C	 B1040000		i1 = xmem[_p + 0]			
40+   	 000D	 80050010		i0 = i0 + (0x10)			
41+   	 000E	 81150010		i1 = i1 + (0x10)			
42+   	 000F	 80140001		x0 = xmem[i1]			
43+   	 0010	 81840000		x1 = ymem[_input_gain + 0]			
44+   	 0011	 00002080		a0 = x0 * x1			
45+   	 0012	 88540000		xmem[i0] = a0			
46+   	 0013				cline_99_0:			
47+   	 0013	 B0040000		i0 = xmem[_p + 0]			
48+   	 0014	 B1040000		i1 = xmem[_p + 0]			
49+   	 0015	 80050020		i0 = i0 + (0x20)			
50+   	 0016	 81150010		i1 = i1 + (0x10)		
51+   	 0017	 88140001		a0 = xmem[i1]		
52+   	 0018	 98540000		xmem[i0] = a0h		
53+   	 0019				cline_104_0:			
54+   	 0019	 B0040000		i0 = xmem[_p + 0]			
55+   	 001A	 B1040000		i1 = xmem[_p + 0]		
56+   	 001B	 80050030		i0 = i0 + (0x30)		
57+   	 001C	 80140001		x0 = xmem[i1]			
58+   	 001D	 817A8000		x1 = (0x8000)		
59+   	 001E	 00002080		a0 = x0 * x1		
60+   	 001F	 88540000		xmem[i0] = a0	
61+   	 0020				cline_107_0:		
62+   	 0020	 B0040000		i0 = xmem[_p + 0]		
63+   	 0021	 B1040000		i1 = xmem[_p + 0]		
64+   	 0022	 80050040		i0 = i0 + (0x40)		
65+   	 0023	 81150020		i1 = i1 + (0x20)		
66+   	 0024	 80140001		x0 = xmem[i1]		
67+   	 0025	 817A8000		x1 = (0x8000)		
68+   	 0026	 00002080		a0 = x0 * x1	 
69+   	 0027	 88540000		xmem[i0] = a0		
70+   	 0028				cline_110_0:			
71+   	 0028	 884A0001		uhalfword(a0) = (0x1)		
72+   	 0029	 00004E80		a0 & a0		 
73+   	 002A	 8408006A		if (a == 0) jmp (else_0)			
74+   	 002B				cline_112_0:		
75+   	 002B	 B0040000		i0 = xmem[_p + 0]			
76+   	 002C	 B1040000		i1 = xmem[_p + 0]			
77+   	 002D	 80050010		i0 = i0 + (0x10)			
78+   	 002E	 81150010		i1 = i1 + (0x10)	
79+   	 002F	 80140001		x0 = xmem[i1]			
80+   	 0030	 81840000		x1 = ymem[_gain2 + 0]		
81+   	 0031	 00002080		a0 = x0 * x1		
82+   	 0032	 88540000		xmem[i0] = a0		
83+   	 0033				cline_115_0:			
84+   	 0033	 B0040000		i0 = xmem[_p + 0]		 
85+   	 0034	 B1040000		i1 = xmem[_p + 0]			
86+   	 0035	 80050050		i0 = i0 + (0x50)			
87+   	 0036	 81150020		i1 = i1 + (0x20)		
88+   	 0037	 80140001		x0 = xmem[i1]		
89+   	 0038	 81840000		x1 = ymem[_gain2 + 0]			
90+   	 0039	 00002080		a0 = x0 * x1			
91+   	 003A	 88540000		xmem[i0] = a0			
92+   	 003B				cline_118_0:			
93+   	 003B	 B0040000		i0 = xmem[_p + 0]		
94+   	 003C	 B1040000		i1 = xmem[_p + 0]			
95+   	 003D	 80050010		i0 = i0 + (0x10)			
96+   	 003E	 81150050		i1 = i1 + (0x50)			
97+   	 003F	 88140001		a0 = xmem[i1]			
98+   	 0040	 89140000		a1 = xmem[i0]			
99+   	 0041	 00004480		a0 = a1 + a0			
100+  	 0042	 98540000		xmem[i0] = a0h			
101+  	 0043				cline_121_0:			
102+  	 0043	 B0040000		i0 = xmem[_p + 0]			
103+  	 0044	 B1040000		i1 = xmem[_p + 0]			
104+  	 0045	 80050050		i0 = i0 + (0x50)			
105+  	 0046	 81150010		i1 = i1 + (0x10)			
106+  	 0047	 80140001		x0 = xmem[i1]			
107+  	 0048	 817A8000		x1 = (0x8000)			
108+  	 0049	 00002080		a0 = x0 * x1			
109+  	 004A	 88540000		xmem[i0] = a0			
110+  	 004B				cline_124_0:			
111+  	 004B	 B0040000		i0 = xmem[_p + 0]			
112+  	 004C	 A1050000		i1 = (0) + (_coefficients)			
113+  	 004D	 80050050		i0 = i0 + (0x50)			
114+  	 004E	 88140000		a0 = xmem[i0]			
115+  	 004F	 A4050000		i4 = (0) + (_x_history1)			
116+  	 0050	 A5050000		i5 = (0) + (_y_history1)			
117+  	 0051	 B1090030		i0 = i1			
118+  	 0052	 B8090031		i1 = i4			
119+  	 0053	 B9090038		i4 = i5			
120+  	 0054	 80880000		call (_second_order_IIR)			
121+  	 0055				cline_125_0:			
122+  	 0055	 B0040000		i0 = xmem[_p + 0]			
123+  	 0056	 A1050000		i1 = (0) + (_coefficients)			
124+  	 0057	 80050050		i0 = i0 + (0x50)			
125+  	 0058	 88140000		a0 = xmem[i0]			
126+  	 0059	 A4050000		i4 = (0) + (_x_history2)			
127+  	 005A	 A5050000		i5 = (0) + (_y_history2)			
128+  	 005B	 B1090030		i0 = i1			
129+  	 005C	 B8090031		i1 = i4			
130+  	 005D	 B9090038		i4 = i5			
131+  	 005E	 80880000		call (_second_order_IIR)			
132+  	 005F				cline_126_0:			
133+  	 005F	 B0040000		i0 = xmem[_p + 0]			
134+  	 0060	 A1050000		i1 = (0) + (_coefficients)			
135+  	 0061	 80050050		i0 = i0 + (0x50)			
136+  	 0062	 88140000		a0 = xmem[i0]			
137+  	 0063	 A4050000		i4 = (0) + (_x_history3)			
138+  	 0064	 A5050000		i5 = (0) + (_y_history3)			
139+  	 0065	 B1090030		i0 = i1			
140+  	 0066	 B8090031		i1 = i4			
141+  	 0067	 B9090038		i4 = i5			
142+  	 0068	 80880000		call (_second_order_IIR)			
143+  	 0069	 8008006E		jmp (endif_0)			
144+  	 006A				cline_127_0:			
145+  	 006A				else_0:			
146+  	 006A	 B0040000		i0 = xmem[_p + 0]			
147+  	 006B	 00004DC0		a0 = 0			
148+  	 006C	 80050010		i0 = i0 + (0x10)			
149+  	 006D	 98540000		xmem[i0] = a0h		
150+  	 006E				cline_131_0:			
151+  	 006E				init_latch_label_0:			
152+  	 006E				endif_0:			
153+  	 006E	 B0040000		i0 = xmem[_p + 0]			
154+  	 006F	 91750001		i1 = i7 - (0x1)			
155+  	 0070	 02087FFF		i0 += 1			
156+  	 0071	 B0440000		xmem[_p + 0] = i0			
157+  	 0072	 88140001		a0 = xmem[i1]			
158+  	 0073	 894A0001		uhalfword(a1) = (0x1)			
159+  	 0074	 90750001		i0 = i7 - (0x1)			
160+  	 0075				label_end_92:			
161+  	 0075	 98540000		xmem[i0] = a0h			
162+  	 0076				cline_95_1:			
163+  	 0076				for_end_0:			
164+  	 0076	 80080077		jmp (__epilogue_222)			
165+  	 0077				__epilogue_222:			
166+  							#i7 = i7 - (0x1)			 
167+  							#i7 -= 1			
168+  	 0077	 81880000		ret			 
169+   >> end of include file: D:/ra150/projekat/resenje/projekat_module/src/p_function.a
169+   >> continuing with file: D:/ra150/projekat/resenje/projekat_module/src/projekat_module_main.a
10    						  
11    						####################### MCV #########################
12    						# The module control vector is a set of Y data variables
13    						# that can be accessed through host communication.
14    						#
15    						projekat_module_Y_Segment	.ydata_ovly
15     >> start of macro: .ydata_ovly
1+    									seg_single projekat_module_Y_Segment, "Y_OVLY", Y
1+     >> start of macro: seg_single
1+    						  .if ( "projekat_module_Y_Segment" != "" ) & defined( ___SegStart_Y_projekat_module_Y_Segment )
2+    						projekat_module_Y_Segment    segment
3+    						  .else
4+    						projekat_module_Y_Segment    segment "Y_OVLY"
5+    							.if "projekat_module_Y_Segment" != ""
6+    	 0000				___SegStart_Y_projekat_module_Y_Segment
7+    							.endif
8+    						  .endif
9+    							#RememberSegmentType
10+    >> end of macro: seg_single
2+     >> end of macro: .ydata_ovly
16    	 0000					.public projekat_module_HOST_MCV
17    	 0000				(null)	 0000	 00000001	 
17    	 0001				(null)	 0001	 50C335D3	 
17    						projekat_module_HOST_MCV MCV_T(.streval(STRUCTURE_INITIALIZATION_STRNG))
18    						
19    						#-------------------- end of MCV ---------------------
20    						
21    						# Copy of MCV in Xmem
22    						projekat_module_X_Segment	.xdata_ovly
22     >> start of macro: .xdata_ovly
1+    									seg_single projekat_module_X_Segment, "X_OVLY", X
1+     >> start of macro: seg_single
1+    						  .if ( "projekat_module_X_Segment" != "" ) & defined( ___SegStart_X_projekat_module_X_Segment )
2+    						projekat_module_X_Segment    segment
3+    						  .else
4+    						projekat_module_X_Segment    segment "X_OVLY"
5+    							.if "projekat_module_X_Segment" != ""
6+    	 0000				___SegStart_X_projekat_module_X_Segment
7+    							.endif
8+    						  .endif
9+    							#RememberSegmentType
10+    >> end of macro: seg_single
2+     >> end of macro: .xdata_ovly
23    	 0000				(null)	 0000	 00000000	 
23    	 0001				(null)	 0001	 00000000	 
23    						projekat_module_MCV	MCV_T		# This is a copy of MCV used by algorithm
24    						
25    	 0002				projekat_module_MCV_end
26    						
27    							.code_ovly
27     >> start of macro: .code_ovly
1+    									seg_single , "CODE_OVLY", CODE
1+     >> start of macro: seg_single
1+    						  .if ( "" != "" ) & defined( ___SegStart_CODE_ )
2+    						    segment
3+    						  .else
4+    						    segment "CODE_OVLY"
5+    							.if "" != ""
6+    						___SegStart_CODE_
7+    							.endif
8+    						  .endif
9+    							#RememberSegmentType
10+    >> end of macro: seg_single
2+     >> end of macro: .code_ovly
28    						##################################################################################
29    						## Called from the Brick or Foreground ISR whenever there 
30    						## is one or more bricks of unprocessed PCM in the IO Buffer.
31    						##
32    						## This function can process only one brick of any channel, but all channels are available
33    						##
34    						## This function is inherently an in-place processor -- the input data and output
35    						## data are in the same IO buffer.
36    						##
37    						## There is an array of I/O buffer pointers, located at YMEM addresses ___X_BY_IOBUFFER_PTRS
38    						## These pointers will point at block N for all channels when this function is 
39    						## called.
40    						#################################################################################
41    	 0000					.public X_S_projekat_module_Brick
42    	 0000				X_S_projekat_module_Brick:
43    						
44    						# some example code...
45    						#	a0 = xmem[projekat_module_MCV.enable]
46    						#	a0&a0 # check to see if we're enabled
47    						#	if (a == 0) jmp X_S_projekat_module_Block_Done
48    						#		i0 = ymem[___X_BY_IOBUFFER_PTRS] #get a first channel pointer
49    						#		do(BRICK_SIZE), >
50    						#			y0 = xmem[projekat_module_MCV.gain] # get a gain MCV parameter
51    						#			x0 = ymem[i0]
52    						#			a0 = x0 * y0; 
53    						#%			ymem[i0] = a0; i0 += 1
54    								
55    							
56    						#   <your code here>
57    	 0000	 80880000	 call _p_function
58    						 
59    						# end of brick function
60    	 0001				X_S_projekat_module_Brick_Done:
61    	 0001	 81880000	  ret
62    						
63    						###############################################################################
64    						## Called from the Brick or Foreground ISR
65    						## This function gets called on frame boundaries (integer multiples of sample-blocks)
66    						##   Example 1:  AAC Frame-size is 1024 samples
67    						##   Example 2:  Our PCM frame-size was chosen to be 256 samples
68    						##
69    						## Use this as another place to act on MCV changes.  This is called more often than
70    						## the Timer functions, but is only called when the DAO clocks are active (only an issue 
71    						## with Decoder chips)
72    						###############################################################################
73    	 0000					.public X_S_projekat_module_Frame
74    	 0002				X_S_projekat_module_Frame:
75    						#   <your code here>
76    	 0002				X_S_projekat_module_Frame_done:
77    	 0002	 81880000	  ret           
78    						
79    						
80    						###############################################################################
81    						## Called from the Brick or Foreground ISR
82    						## Called only when the Timer flag is set (gets set by the Timer ISR)
83    						## Use this to act on MCV changes when the block and frame functions are not being called,
84    						## e.g. when there is no input audio signal.
85    						###############################################################################
86    	 0000					.public X_S_projekat_module_Timer
87    	 0003				X_S_projekat_module_Timer:
88    						#   <your code here>
89    	 0003				X_S_projekat_module_Timer_done:
90    	 0003	 81880000	  ret
91    						
92    						###############################################################################
93    						## Called from an infinite-loop in the main body of the OS code
94    						## Can be interrupted, so exercise caution when using global vars that are 
95    						## used in the foreground ISR
96    						###############################################################################
97    	 0000					.public X_S_projekat_module_Background
98    	 0004				X_S_projekat_module_Background:
99    						
100   						# SAMPLE CODE:
101   						#	MCV used as a shadow copy on host MCV
102   						#   This code will copy module_test_HOST_MCV to module_test_MCV
103   						#	i0 = (projekat_module_HOST_MCV)
104   						#	i1 = (projekat_module_MCV)
105   						#	nm0 = (1)
106   						#	nm1 = (1)
107   						#	do(sizeof(MCV_T)), >
108   						#		a0 = ymem[i0]; i0 += n
109   						#%		xmem[i1] = a0; i1 += n
110   						
111   						#   <your code here>
112   	 0004				X_S_projekat_module_Background_Done:
113   	 0004	 81880000	  ret
114   						
115   						##################################################################################
116   						## Called from the Brick or Foreground ISR
117   						## Used for requesting memory from the heap
118   						## Called immediately after the frame functions are called and immediately prior 
119   						## to the PostMalloc functions.
120   						##
121   						## This function is only called if one or more modules set the X_VX_NextFrm_Reinit_Req 
122   						## flag (in the Frame function).
123   						## When this happens, all modules' PreMalloc functions get called so that each module 
124   						## has the chance to ask for heap memory.
125   						## 
126   						## If this function gets called, the OS has already freed all of the heap, and all heap-using modules
127   						## MUST request heap again.
128   						##
129   						## Examples of Heap Requests:
130   						## 
131   						#####  Example 1:  Request 512 words from XMEM
132   						#####  i0 = (VX_Buffer_0_Ptr) ### Os place the address of the malloced RAM in this var in XRAM
133   						#####  uhalfword(x0) = (0x200)
134   						#####  call cl_mallocX
135   						
136   						#####  Example 2:  Request 768 words from YMEM
137   						#####  i0 = (VX_Buffer_1_Ptr) ### Os place the address of the malloced RAM in this var in XRAM
138   						#####  uhalfword(x0) = (0x300)
139   						#####  call cl_mallocY
140   						
141   						#####  Example 3:  Request 512 of words from XMEM aligned to a modulo boundary
142   						#####  i0 = (VX_Buffer_2_Ptr) ### Os place the address of the malloced RAM in this var in XRAM
143   						#####  uhalfword(x0) = (0x200)
144   						#####  call cl_mallocModX
145   						
146   						#####  Example 4:  Request 64 words from LMEM aligned to a modulo boundary
147   						#####  i0 = (VX_Buffer_3_Ptr) ### Os place the address of the malloced RAM in this var in XRAM
148   						#####  uhalfword(x0) = (64)
149   						#####  call cl_mallocModL
150   						
151   						### There are 6 types of malloc requests: X, Y, L modulo and non-modulo
152   						### Mallocation is all or nothing.  If there is not enough available heap to accomodate
153   						### the entire set of requests, the systems halts.
154   						
155   						### If the Malloc succeeds, the OS calls the Post Malloc functions.
156   						#################################################################################
157   	 0000					.public X_S_projekat_module_PreMalloc
158   	 0005				X_S_projekat_module_PreMalloc:
159   						#   <your code here>
160   	 0005				X_S_projekat_module_PreMalloc_Done:
161   	 0005	 81880000	  ret
162   						
163   						##################################################################################
164   						## Called from the Brick or Foreground ISR
165   						## Called if the mallocations requested by the modules' Pre-Mallocs succeeds
166   						## This gives the module designer a chance to act upon the newly acquired buffers
167   						## if so desired.  For example, a malloced projekat_module-filter history-buffer should be 
168   						## cleared here.
169   						##
170   						## This function is also a good place to set a malloc-success flag for the benefit
171   						## of the Block function.  That is, the Block function should never try to operate on
172   						## a buffer that has not yet been malloced
173   						#################################################################################
174   	 0000					.public X_S_projekat_module_PostMalloc
175   	 0006				X_S_projekat_module_PostMalloc:
176   						#   <your code here>
177   	 0006				X_S_projekat_module_PostMalloc_Done:
178   	 0006	 81880000	  ret
179   						
180   						###############################################################################
181   						## Unconditional initializations (i.e., vars whose values don't depend on MCV)
182   						## This function gets called before the KickStart message is received and acted-on
183   						## Called only when the OS re-boots
184   						###############################################################################
185   	 0000					.public X_S_projekat_module_PreKickstart
186   	 0007				X_S_projekat_module_PreKickstart:
187   						#   <your code here>
188   	 0007				X_S_projekat_module_PreKickstart_done:
189   						  
190   	 0007	 81880000	  ret
191   						
192   						
193   						###############################################################################
194   						## Unconditional initializations (i.e., vars whose values don't depend on MCV)
195   						##    OR
196   						## Conditional initializations (i.e., vars whose values depend on MCV)
197   						##
198   						## This function gets called immediately after the KickStart message is received
199   						## by the OS and acted-on (i.e., prior to any other Framework Entry-point).
200   						##
201   						## This function also gets called upon App-Restart (which happens after recovering 
202   						## from an audio under-flow).
203   						##
204   						## This function gets called before any block-processing functions are called.
205   						##
206   						## An example of the kind of initialization that must happen here would be any 
207   						## filter state that must be cleared prior to starting audio again. 
208   						###############################################################################
209   	 0000					.public X_S_projekat_module_PostKickstart
210   	 0008				X_S_projekat_module_PostKickstart:
211   						#   <your code here>
212   	 0008				X_S_projekat_module_PostKickstart_done:
213   						                     
214   	 0008	 81880000	  ret
215   						(null)
				 SYMBOL TABLE 

    Name                                                                                    Type                  Value 

BRICK_SIZE                                                                      			  Unused Number				      16 (10H)
MAX_HARDWARE_DSP_CHANNELS_FOR_ANY_CIRRUS_PLATFORM                               			  Unused Number				      16 (10H)
STRUCTURE_INITIALIZATION_STRNG                                                  					 String		   '0x1, 0x50c335d3' 
X_S_projekat_module_Background                                                  			  Public Relocatable       projekat_module_main_GEN_0001:0004H
X_S_projekat_module_Background_Done                                             			  Unused Relocatable        projekat_module_main_GEN_0001:0004H
X_S_projekat_module_Brick                                                       			  Public Relocatable       projekat_module_main_GEN_0001:0000H
X_S_projekat_module_Brick_Done                                                  			  Unused Relocatable        projekat_module_main_GEN_0001:0001H
X_S_projekat_module_Frame                                                       			  Public Relocatable       projekat_module_main_GEN_0001:0002H
X_S_projekat_module_Frame_done                                                  			  Unused Relocatable        projekat_module_main_GEN_0001:0002H
X_S_projekat_module_PostKickstart                                               			  Public Relocatable       projekat_module_main_GEN_0001:0008H
X_S_projekat_module_PostKickstart_done                                          			  Unused Relocatable        projekat_module_main_GEN_0001:0008H
X_S_projekat_module_PostMalloc                                                  			  Public Relocatable       projekat_module_main_GEN_0001:0006H
X_S_projekat_module_PostMalloc_Done                                             			  Unused Relocatable        projekat_module_main_GEN_0001:0006H
X_S_projekat_module_PreKickstart                                                			  Public Relocatable       projekat_module_main_GEN_0001:0007H
X_S_projekat_module_PreKickstart_done                                           			  Unused Relocatable        projekat_module_main_GEN_0001:0007H
X_S_projekat_module_PreMalloc                                                   			  Public Relocatable       projekat_module_main_GEN_0001:0005H
X_S_projekat_module_PreMalloc_Done                                              			  Unused Relocatable        projekat_module_main_GEN_0001:0005H
X_S_projekat_module_Timer                                                       			  Public Relocatable       projekat_module_main_GEN_0001:0003H
X_S_projekat_module_Timer_done                                                  			  Unused Relocatable        projekat_module_main_GEN_0001:0003H
_COMMON_INC_PATH_                                                               					 Define                 "C:/CirrusDSP/crystal32/common/inc/"
_DSP_                                                                           			  Unused Variable		        0 (0H)
_LOCAL_INC_PATH_                                                                					 Define                 "inc/"
_LOCAL_SRC_PATH_                                                                					 Define                 "src/"
_ROUTER_INC_PATH_                                                               					 Define                 "rom_inc/"
__CASM_VER__                                                                    			  Unused Variable		        0 (701H)
__X_BL_TEMPBUFF7                                                                					 External   
___SegStart_X_projekat_module_X_Segment                                         			  Unused Relocatable        projekat_module_X_Segment:0000H
___SegStart_Y_projekat_module_Y_Segment                                         			  Unused Relocatable        projekat_module_Y_Segment:0000H
___X_BL_TEMPBUFF                                                                					 External   
___X_BL_TEMPBUFF0                                                               					 External   
___X_BL_TEMPBUFF1                                                               					 External   
___X_BL_TEMPBUFF10                                                              					 External   
___X_BL_TEMPBUFF11                                                              					 External   
___X_BL_TEMPBUFF12                                                              					 External   
___X_BL_TEMPBUFF13                                                              					 External   
___X_BL_TEMPBUFF14                                                              					 External   
___X_BL_TEMPBUFF15                                                              					 External   
___X_BL_TEMPBUFF2                                                               					 External   
___X_BL_TEMPBUFF3                                                               					 External   
___X_BL_TEMPBUFF4                                                               					 External   
___X_BL_TEMPBUFF5                                                               					 External   
___X_BL_TEMPBUFF6                                                               					 External   
___X_BL_TEMPBUFF8                                                               					 External   
___X_BL_TEMPBUFF9                                                               					 External   
___X_BX_TEMPBUFF                                                                					 External   
___X_BX_TEMPBUFF0                                                               					 External   
___X_BX_TEMPBUFF1                                                               					 External   
___X_BX_TEMPBUFF10                                                              					 External   
___X_BX_TEMPBUFF11                                                              					 External   
___X_BX_TEMPBUFF12                                                              					 External   
___X_BX_TEMPBUFF13                                                              					 External   
___X_BX_TEMPBUFF14                                                              					 External   
___X_BX_TEMPBUFF15                                                              					 External   
___X_BX_TEMPBUFF2                                                               					 External   
___X_BX_TEMPBUFF3                                                               					 External   
___X_BX_TEMPBUFF4                                                               					 External   
___X_BX_TEMPBUFF5                                                               					 External   
___X_BX_TEMPBUFF6                                                               					 External   
___X_BX_TEMPBUFF7                                                               					 External   
___X_BX_TEMPBUFF8                                                               					 External   
___X_BX_TEMPBUFF9                                                               					 External   
___X_BY_IOBUFFER_PTRS                                                           					 External   
___X_BY_TEMPBUFF                                                                					 External   
___X_BY_TEMPBUFF0                                                               					 External   
___X_BY_TEMPBUFF1                                                               					 External   
___X_BY_TEMPBUFF10                                                              					 External   
___X_BY_TEMPBUFF11                                                              					 External   
___X_BY_TEMPBUFF12                                                              					 External   
___X_BY_TEMPBUFF13                                                              					 External   
___X_BY_TEMPBUFF14                                                              					 External   
___X_BY_TEMPBUFF15                                                              					 External   
___X_BY_TEMPBUFF2                                                               					 External   
___X_BY_TEMPBUFF3                                                               					 External   
___X_BY_TEMPBUFF4                                                               					 External   
___X_BY_TEMPBUFF5                                                               					 External   
___X_BY_TEMPBUFF6                                                               					 External   
___X_BY_TEMPBUFF7                                                               					 External   
___X_BY_TEMPBUFF8                                                               					 External   
___X_BY_TEMPBUFF9                                                               					 External   
___X_VX_NEXTFRM_REINIT_REQ                                                      					 External   
___X_VX_PPM_INPUTMODE                                                           					 External   
___X_VX_PPM_INPUT_CHANNELS                                                      					 External   
___X_VX_PPM_OUTPUTMODE                                                          					 External   
___X_VX_PPM_OUTPUT_CHANNELS                                                     					 External   
___X_VX_PPM_SAMPLERATE                                                          					 External   
___X_VX_PPM_VALID_CHANNELS                                                      					 External   
___X_VX_REINIT                                                                  					 External   
___X_VX_UNDERFLOW                                                               					 External   
___X_VY_BRICK_SIZE                                                              					 External   
__epilogue_222                                                                  			         Relocatable         projekat_module_main_GEN_0000:0077H
_cl_get_mcv_pointer                                                             					 External   
_cl_mcv_peek                                                                    					 External   
_cl_mcv_poke                                                                    					 External   
_coefficients                                                                   					 External   
_framework_interface_asm_h_                                                     			  Unused Relocatable        __INIT:0000H
_gain2                                                                          					 External   
_input_gain                                                                     					 External   
_meter_h_                                                                       			  Unused Relocatable        __INIT:0000H
_p                                                                              					 External   
_p_function                                                                     			  Public Relocatable       projekat_module_main_GEN_0000:0000H
_response_h_                                                                    			  Unused Relocatable        __INIT:0000H
_sampleBuffer                                                                   					 External   
_second_order_IIR                                                               					 External   
_x_history1                                                                     					 External   
_x_history2                                                                     					 External   
_x_history3                                                                     					 External   
_y_history1                                                                     					 External   
_y_history2                                                                     					 External   
_y_history3                                                                     					 External   
cl_I2C_Abort_Message                                                            					 External   
cl_I2C_Command_Word                                                             					 External   
cl_I2C_Nonblocking_ReadMsg                                                      					 External   
cl_I2C_Nonblocking_WriteMsg                                                     					 External   
cl_I2C_ReadMsg                                                                  					 External   
cl_I2C_WriteMsg                                                                 					 External   
cl_clearNM0_7                                                                   					 External   
cl_get_i2c_cmd_word                                                             					 External   
cl_get_i2c_msg_busy                                                             					 External   
cl_get_i2c_msg_error                                                            					 External   
cl_get_i2c_msg_fifo_ptr                                                         					 External   
cl_get_i2c_msg_pending_reads                                                    					 External   
cl_get_i2c_msg_pending_writes                                                   					 External   
cl_mallocL                                                                      					 External   
cl_mallocModL                                                                   					 External   
cl_mallocModX                                                                   					 External   
cl_mallocModY                                                                   					 External   
cl_mallocX                                                                      					 External   
cl_mallocY                                                                      					 External   
cl_os_register_gpi_handler                                                      					 External   
cl_peek_gpi                                                                     					 External   
cl_poke_gpo                                                                     					 External   
cl_send_unsol_msg                                                               					 External   
cline_104_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:0019H
cline_107_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:0020H
cline_110_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:0028H
cline_112_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:002BH
cline_115_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:0033H
cline_118_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:003BH
cline_121_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:0043H
cline_124_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:004BH
cline_125_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:0055H
cline_126_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:005FH
cline_127_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:006AH
cline_131_0                                                                     			  Unused Relocatable        projekat_module_main_GEN_0000:006EH
cline_90_0                                                                      			  Unused Relocatable        projekat_module_main_GEN_0000:0000H
cline_93_0                                                                      			  Unused Relocatable        projekat_module_main_GEN_0000:0002H
cline_95_0                                                                      			  Unused Relocatable        projekat_module_main_GEN_0000:0004H
cline_95_1                                                                      			  Unused Relocatable        projekat_module_main_GEN_0000:0076H
cline_98_0                                                                      			  Unused Relocatable        projekat_module_main_GEN_0000:000BH
cline_99_0                                                                      			  Unused Relocatable        projekat_module_main_GEN_0000:0013H
else_0                                                                          			         Relocatable         projekat_module_main_GEN_0000:006AH
endif_0                                                                         			         Relocatable         projekat_module_main_GEN_0000:006EH
for_end_0                                                                       			  Unused Relocatable        projekat_module_main_GEN_0000:0076H
init_latch_label_0                                                              			  Unused Relocatable        projekat_module_main_GEN_0000:006EH
isDefined                                                                       			  Unused Number				      1 (1H)
label_begin_92                                                                  			  Unused Relocatable        projekat_module_main_GEN_0000:0004H
label_end_92                                                                    			         Relocatable         projekat_module_main_GEN_0000:0075H
projekat_module_HOST_MCV.enable                                                 			  Unused Relocatable        projekat_module_Y_Segment:0000H
projekat_module_HOST_MCV.input_gain                                             			  Unused Relocatable        projekat_module_Y_Segment:0001H
projekat_module_MCV                                                             			  Unused Struct Relocatable projekat_module_X_Segment:0000H
projekat_module_MCV.enable                                                      			  Unused Relocatable        projekat_module_X_Segment:0000H
projekat_module_MCV.input_gain                                                  			  Unused Relocatable        projekat_module_X_Segment:0001H
projekat_module_MCV_end                                                         			  Unused Relocatable        projekat_module_X_Segment:0002H
projekat_module_X_Segment                                                       			  Unused Relocatable        projekat_module_X_Segment:0000H
projekat_module_Y_Segment                                                       			  Unused Relocatable        projekat_module_Y_Segment:0000H

	       SEGMENTS:

Size			  Name										 Class
0000H	 __INIT                                  			 CODE                                    
0078H	 projekat_module_main_GEN_0000           			 CODE_OVLY                               
0002H	 projekat_module_Y_Segment               			 Y_OVLY                                  
0002H	 projekat_module_X_Segment               			 X_OVLY                                  
0009H	 projekat_module_main_GEN_0001           			 CODE_OVLY                               
